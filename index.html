<!doctype html>
<html>
<head>
	<meta charset="UTF-8" />
	<title>JTball</title>
	<script src="js/phaser.min.js"></script>
</head>
<body>

	<script type="text/javascript">

	window.onload = function() {

		var settings = {

			player1: {

				keys: {

					up: Phaser.Keyboard.W,
					left: Phaser.Keyboard.A,
					right: Phaser.Keyboard.D,
					down: Phaser.Keyboard.S,

				},

				powerLineColor: 0x00ff00,

			},

			player2: {

				keys: {

					up: Phaser.Keyboard.UP,
					left: Phaser.Keyboard.LEFT,
					right: Phaser.Keyboard.RIGHT,
					down: Phaser.Keyboard.DOWN,

				},

				powerLineColor: 0xff0000,

			},

			ballProperties: {

				mass: 5,
				bouncinessBetweenBalls: 0.95,
				bouncinessWithWorld: 0.9,

			},

		}

		var game = new Phaser.Game(1024, 500, Phaser.AUTO, '', { preload: preload, create: create, update: update, render: render });

		function preload () {

			game.load.image('playball', 'images/playball.png');
			game.load.image('player1', 'images/player1.png');
			game.load.image('player2', 'images/player2.png');

		}

		function create () {

			game.stage.backgroundColor = "#F0F0F0";

			game.physics.startSystem(Phaser.Physics.P2JS);

			//  Set the world (global) gravity
			game.physics.p2.gravity.y = 200;

			// Create players (sprites)
			game.players = [];

			game.players.player1 = game.add.sprite(game.world.centerX / 4, game.world.centerY / 2, 'player1');
			game.players.player1.anchor.setTo(0.5, 0.5);
			game.players.player1.scale.set(0.5, 0.5);

			game.players.player2 = game.add.sprite(game.world.centerX * 1.75, game.world.centerY / 2, 'player2');
			game.players.player2.anchor.setTo(0.5, 0.5);
			game.players.player2.scale.set(0.5, 0.5);

			// And create the playing ball
			game.playball = game.add.sprite(game.world.centerX, game.world.centerY / 4, 'playball');
			game.playball.anchor.setTo(0.5, 0.5);
			game.playball.scale.set(0.5, 0.5);


			// Apply physics to players
			game.physics.p2.enable( [ game.players.player1, game.players.player2, game.playball]);
			game.physics.p2.boundsCollideWith = [ game.players.player1, game.players.player2, game.playball];

			// By default the Body is a rectangle. Let's turn it into a circle with a radius in pixels		
			game.players.player1.body.setCircle(56);
			game.players.player2.body.setCircle(56);
			game.playball.body.setCircle(56);

			game.players.player1.body.mass = game.players.player2.body.mass = game.playball.body.mass = settings.ballProperties.mass;

			// Create materials, which define how the interaction between these sprites occcur (friction, bounciness etc)
			var ballMaterial = game.physics.p2.createMaterial('spriteMaterial', game.players.player1.body);
			var worldMaterial = game.physics.p2.createMaterial('worldMaterial');
			game.physics.p2.setWorldMaterial(worldMaterial, true, true, true, true);

			// Apply materials to other balls as well
			game.players.player2.body.setMaterial(ballMaterial);
			game.playball.body.setMaterial(ballMaterial);

			// Contact materials
			var contactMaterialWithWorld = game.physics.p2.createContactMaterial(ballMaterial, worldMaterial);
			var contactMaterialBetweenBalls = game.physics.p2.createContactMaterial(ballMaterial, ballMaterial);

			// Friction to use in the contact of these two materials.
			contactMaterialWithWorld.friction = 5;

			// Restitution (i.e. how bouncy it is!) to use in the contact of these two materials.
    		contactMaterialWithWorld.restitution = settings.ballProperties.bouncinessWithWorld;  

    		// Stiffness of the resulting ContactEquation that this ContactMaterial generate.
			contactMaterialWithWorld.stiffness = 1e7;

			// Relaxation of the resulting ContactEquation that this ContactMaterial generate.
    		contactMaterialWithWorld.relaxation = 3;

    		// Stiffness of the resulting FrictionEquation that this ContactMaterial generate.
    		contactMaterialWithWorld.frictionStiffness = 1e7;

    		// Relaxation of the resulting FrictionEquation that this ContactMaterial generate.
    		contactMaterialWithWorld.frictionRelaxation = 300;

    		// Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.
    		contactMaterialWithWorld.surfaceVelocity = 0;        

    		// And same logic to contacts between balls (I enjoy saying that)
			contactMaterialBetweenBalls.friction = 30;
    		contactMaterialBetweenBalls.restitution = settings.ballProperties.bouncinessBetweenBalls;			
    		contactMaterialBetweenBalls.stiffness = 1e7;
    		contactMaterialBetweenBalls.relaxation = 3;
    		contactMaterialBetweenBalls.frictionStiffness = 1e7;
    		contactMaterialBetweenBalls.frictionRelaxation = 3;
    		contactMaterialBetweenBalls.surfaceVelocity = 0;

    		// Power represents charging when user pushes the down-button, and when released launched into the ball
    		game.players.player1.power = { value: 0, angle: 0 };
    		game.players.player2.power = { value: 0, angle: 0 };

    		// Create power lines to balls (these indicate the launch power and direction)
    		game.players.player1.power.line = new Phaser.Line(game.players.player1.body.x, game.players.player1.body.y, game.players.player1.body.x, game.players.player1.body.y);
    		game.players.player1.power.line.width = 100;
    		game.players.player1.power.line.graphics = game.add.graphics(0,0);
    		game.players.player2.power.line = new Phaser.Line(game.players.player2.body.x, game.players.player2.body.y, game.players.player2.body.x, game.players.player2.body.y);
    		game.players.player2.power.line.width = 100;
    		game.players.player2.power.line.graphics = game.add.graphics(0,0);

			// Bind the keys to players
			game.players.player1.keys = {};
			game.players.player1.keys.up = game.input.keyboard.addKey(settings.player1.keys.up);
			game.players.player1.keys.right = game.input.keyboard.addKey(settings.player1.keys.right);
			game.players.player1.keys.left = game.input.keyboard.addKey(settings.player1.keys.left);
			game.players.player1.keys.down = game.input.keyboard.addKey(settings.player1.keys.down);
			game.players.player2.keys = {};
			game.players.player2.keys.up = game.input.keyboard.addKey(settings.player2.keys.up);
			game.players.player2.keys.right = game.input.keyboard.addKey(settings.player2.keys.right);
			game.players.player2.keys.left = game.input.keyboard.addKey(settings.player2.keys.left);
			game.players.player2.keys.down = game.input.keyboard.addKey(settings.player2.keys.down);

		}

		function update () {

			// Logic for movement
			if (game.players.player1.keys.left.isDown) {
				game.players.player1.power.angle += -0.1;
			}
			if (game.players.player1.keys.right.isDown) {				
				game.players.player1.power.angle += 0.1;
			}
			if (game.players.player1.keys.down.isDown) {
				game.players.player1.power.value += 1;
				if (game.players.player1.power.value > 100) {
					game.players.player1.power.value = 100;
				}
			}
			// When down-key is relesed, apply to power to the balls movement
			if (game.players.player1.keys.down.justUp) {
				game.players.player1.body.velocity.x += Math.cos(game.players.player1.power.angle) * game.players.player1.power.value * 15;
				game.players.player1.body.velocity.y += Math.sin(game.players.player1.power.angle) * game.players.player1.power.value * 15;
				game.players.player1.power.value = 0;
			}

			if (game.players.player2.keys.left.isDown) {
				game.players.player2.power.angle += -0.1;
			}
			if (game.players.player2.keys.right.isDown) {				
				game.players.player2.power.angle += 0.1;
			}
			if (game.players.player2.keys.down.isDown) {
				game.players.player2.power.value += 1;
				if (game.players.player2.power.value > 100) {
					game.players.player2.power.value = 100;
				}
			}
			if (game.players.player2.keys.down.justUp) {
				game.players.player2.body.velocity.x += Math.cos(game.players.player2.power.angle) * game.players.player2.power.value * 15;
				game.players.player2.body.velocity.y += Math.sin(game.players.player2.power.angle) * game.players.player2.power.value * 15;
				game.players.player2.power.value = 0;
			}

			// Update the power lines
			game.players.player1.power.line.fromAngle(game.players.player1.body.x, game.players.player1.body.y, game.players.player1.power.angle, game.players.player1.power.value);
			game.players.player2.power.line.fromAngle(game.players.player2.body.x, game.players.player2.body.y, game.players.player2.power.angle, game.players.player2.power.value);

			// Draw the graphics for the lines
			game.players.player1.power.line.graphics.clear();
			game.players.player1.power.line.graphics.lineStyle(10, settings.player1.powerLineColor, 1);
			game.players.player1.power.line.graphics.moveTo(game.players.player1.power.line.start.x, game.players.player1.power.line.start.y);
			game.players.player1.power.line.graphics.lineTo(game.players.player1.power.line.end.x, game.players.player1.power.line.end.y);
			game.players.player2.power.line.graphics.clear();
			game.players.player2.power.line.graphics.lineStyle(10, settings.player2.powerLineColor, 1);
			game.players.player2.power.line.graphics.moveTo(game.players.player2.power.line.start.x, game.players.player2.power.line.start.y);
			game.players.player2.power.line.graphics.lineTo(game.players.player2.power.line.end.x, game.players.player2.power.line.end.y);
		}

		function render() {

		    //game.debug.geom(game.players.player1.power.line);
		    //game.debug.lineInfo(game.players.player1.power.line, 32, 32);

		}

	};

	</script>

</body>
</html>